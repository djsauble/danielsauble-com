---
---

<canvas id="background-canvas"></canvas>

<script is:inline>
  const canvas = document.getElementById('background-canvas');
  const ctx = canvas.getContext('2d');

  const spacing = 50; // Spacing between dots in pixels. Range: 20 to 100.
  const damping = 1.1; // Controls how quickly waves dissipate. Range: 0.1 to 0.9.=
  const baseColor = [240, 240, 240]; // Subtle grey color (RGB). Range: [0, 0, 0] to [255, 255, 255].
  const targetColor = [255, 255, 255]; // Target color for the animation (RGB). Range: [0, 0, 0] to [255, 255, 255].
  const colorIntensityMultiplier = 1.5; // Multiplier for color intensity based on displacement. Range: 50 to 200.
  const fps = 30; // Frames per second for the animation. Range: 20 to 60.
  const pulseMagnitude = 100; // Magnitude of the displacement pulse on click. Range: 50 to 200.

  const hexHeight = spacing * Math.sqrt(Math.PI);
  const vertSpacing = hexHeight * 0.5 - 2;
  const horizSpacing = spacing * 3;

  let gridWidth;
  let gridHeight;
  let grid;
  let previousGrid;

  function initializeGrid() {
    gridWidth = Math.ceil(canvas.width / (spacing * 1.5)) + 1;
    gridHeight = Math.ceil(canvas.height / vertSpacing) + 1;

    grid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));
    previousGrid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));
  }

  function updateSimulation() {
    const nextGrid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));

    for (let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        let sumNeighbors = 0;
        let neighborCount = 0;

        // Hexagonal neighbors
        const neighbors = [
          [i - 1, j], [i + 1, j], // Left and right
          [i, j - 1], [i, j + 1], // Top and bottom
        ];

        if (j % 2 === 0) { // Even rows
          neighbors.push([i - 1, j - 1], [i - 1, j + 1]);
        } else { // Odd rows
          neighbors.push([i + 1, j - 1], [i + 1, j + 1]);
        }

        for (const [ni, nj] of neighbors) {
          if (ni >= 0 && ni < gridWidth && nj >= 0 && nj < gridHeight) {
            sumNeighbors += grid[ni][nj];
            neighborCount++;
          }
        }

        const newValue = (sumNeighbors / neighborCount) - previousGrid[i][j];
        nextGrid[i][j] = newValue * damping;
      }
    }
    previousGrid = grid;
    grid = nextGrid;
  }

  function drawAnimation() {
    console.log("Animating!");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        const displacement = grid[i][j];

        // Vary color based on displacement
        const colorDelta = Math.abs(displacement) * colorIntensityMultiplier;
        let r = 255;
        let g = 255;
        let b = 255;

        // Red channel
        if (baseColor[0] < targetColor[0]) {
          r = Math.min(targetColor[0], baseColor[0] + colorDelta);
        }
        else {
          r = Math.max(targetColor[0], baseColor[0] - colorDelta);
        }

        // Green channel
        if (baseColor[1] < targetColor[1]) {
          g = Math.min(targetColor[1], baseColor[1] + colorDelta);
        }
        else {
          g = Math.max(targetColor[1], baseColor[1] - colorDelta);
        }

        // Blue channel
        if (baseColor[2] < targetColor[2]) {
          b = Math.min(targetColor[2], baseColor[2] + colorDelta);
        }
        else {
          b = Math.max(targetColor[2], baseColor[2] - colorDelta);
        }

        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

        const x = i * horizSpacing + (j % 2) * (horizSpacing / 2);
        const y = j * vertSpacing;

        drawHexagon(x, y, spacing);
      }
    }
  }

  function drawHexagon(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));

    for (let i = 1; i <= 6; i++) {
      ctx.lineTo(x + size * Math.cos(i * Math.PI / 3), y + size * Math.sin(i * Math.PI / 3));
    }

    ctx.fill();
  }

  // Initial draw and resize handling
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeGrid();
    drawAnimation(); // Redraw on resize
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas(); // Initial size

  // Animation loop
  let lastTime = 0;
  const frameDuration = 1000 / fps;

  function animate(currentTime) {
    requestAnimationFrame(animate);

    const deltaTime = currentTime - lastTime;

    if (deltaTime > frameDuration) {
      lastTime = currentTime - (deltaTime % frameDuration);
      updateSimulation();
      drawAnimation();
    }
  }
  animate(0); // Start the animation loop

  // Mouse interaction
  canvas.addEventListener('click', (event) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    let gridY = Math.floor(mouseY / vertSpacing);
    let gridX = Math.floor((mouseX - (gridY % 2) * (horizSpacing / 2)) / horizSpacing);

    if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
      // Apply a displacement pulse at the mouse location
      grid[gridX][gridY] = pulseMagnitude; // Adjust the magnitude of the pulse as needed
    }
  });

</script>

<style>
  #background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }
</style>