---
---

<canvas id="background-canvas"></canvas>

<script is:inline>
  const canvas = document.getElementById('background-canvas');
  const ctx = canvas.getContext('2d');

  const fps = 30; // Frames per second for the animation. Range: 20 to 60.
  const frameDuration = 1000 / fps;
  const convergenceThreshold = 0.99; // Displacement value close to zero
  const convergencePercentage = 0.99; // Percentage of cells that must be converged

  const spacing = 60; // Spacing between dots in pixels. Range: 20 to 100.
  const damping = 1.2; // Controls how quickly waves dissipate. Range: 0.1 to 0.9.=
  const colors = [[240, 240, 240], [242, 228, 246], [205, 205, 239], [255, 243, 194], [215, 238, 215]]; // Subtle grey color (RGB). Range: [0, 0, 0] to [255, 255, 255].
  let currentColor = 0;
  let nextColor = 1;
  const colorIntensityMultiplier = 1; // Multiplier for color intensity based on displacement. Range: 50 to 200.
  const pulseMagnitude = 20; // Magnitude of the displacement pulse on click. Range: 50 to 200.

  const hexHeight = spacing * Math.sqrt(Math.PI);
  const vertSpacing = hexHeight * 0.5 - 2;
  const horizSpacing = spacing * 3;

  let gridWidth;
  let gridHeight;
  let grid;
  let previousGrid;

  function initializeGrid() {
    gridWidth = Math.ceil(canvas.width / (spacing * 3));
    gridHeight = Math.ceil(canvas.height / vertSpacing);

    grid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));
    previousGrid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));
  }

  function updateSimulation() {
    const nextGrid = Array(gridWidth).fill(null).map(() => Array(gridHeight).fill(0));

    for (let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        let sumNeighbors = 0;
        let neighborCount = 0;

        // Hexagonal neighbors
        const neighbors = [
          [i, j - 2], [i, j + 2],
          [i, j - 1], [i, j + 1],
        ];

        if (j % 2 === 0) { // Even rows
          neighbors.push([i - 1, j - 1], [i - 1, j + 1]);
        } else {
          neighbors.push([i + 1, j - 1], [i + 1, j + 1]); 
        }

        for (const [ni, nj] of neighbors) {
          if (ni >= 0 && ni < gridWidth && nj >= 0 && nj < gridHeight) {
            sumNeighbors += grid[ni][nj];
            neighborCount++;
          }
        }

        const newValue = (sumNeighbors / neighborCount) - previousGrid[i][j];
        nextGrid[i][j] = newValue * damping;
      }
    }
    previousGrid = grid;
    grid = nextGrid;
  }

  function drawAnimation() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        const displacement = grid[i][j];

        // Vary color based on displacement
        const colorDelta = Math.abs(displacement) * colorIntensityMultiplier;
        let r = 255;
        let g = 255;
        let b = 255;

        // Red channel
        if (colors[currentColor][0] < colors[nextColor][0]) {
          r = Math.min(colors[nextColor][0], colors[currentColor][0] + colorDelta);
        }
        else {
          r = Math.max(colors[nextColor][0], colors[currentColor][0] - colorDelta);
        }

        // Green channel
        if (colors[currentColor][1] < colors[nextColor][1]) {
          g = Math.min(colors[nextColor][1], colors[currentColor][1] + colorDelta);
        }
        else {
          g = Math.max(colors[nextColor][1], colors[currentColor][1] - colorDelta);
        }

        // Blue channel
        if (colors[currentColor][2] < colors[nextColor][2]) {
          b = Math.min(colors[nextColor][2], colors[currentColor][2] + colorDelta);
        }
        else {
          b = Math.max(colors[nextColor][2], colors[currentColor][2] - colorDelta);
        }

        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

        const x = i * horizSpacing + (j % 2) * (horizSpacing / 2);
        const y = j * vertSpacing;

        drawHexagon(x, y, spacing);

        // Draw coordinates for debugging
        ctx.fillStyle = 'black'; // Set text color
        ctx.font = '12px Arial'; // Set font
        ctx.textAlign = 'center'; // Center text horizontally
        ctx.textBaseline = 'middle'; // Center text vertically
        ctx.fillText(`${Math.round(displacement)}`, x, y); // Draw the coordinates
        }
    }
  }

  function drawHexagon(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));

    for (let i = 1; i <= 6; i++) {
      ctx.lineTo(x + size * Math.cos(i * Math.PI / 3), y + size * Math.sin(i * Math.PI / 3));
    }

    ctx.fill();
  }

  // Initial draw and resize handling
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeGrid();
    drawAnimation(); // Redraw on resize
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas(); // Initial size

  // Animation loop
  let lastTime = 0;
  let animationFrameId;

  function checkConvergence() {
    let convergedCount = 0;
    const totalCells = gridWidth * gridHeight;

    for (let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        if (Math.abs(grid[i][j]) > convergenceThreshold) {
          convergedCount++;
        }
      }
    }

    return convergedCount / totalCells >= convergencePercentage;
  }

  function animate(currentTime) {
    animationFrameId = requestAnimationFrame(animate);

    const deltaTime = currentTime - lastTime;

    if (deltaTime > frameDuration) {
      lastTime = currentTime - (deltaTime % frameDuration);
      updateSimulation();
      drawAnimation();

      if (checkConvergence()) {
        cancelAnimationFrame(animationFrameId);
        initializeGrid(); // Reset grid for next interaction
        advanceColors();
        drawAnimation();
      }
    }
  }

  function advanceColors() {
    currentColor = (currentColor + 1) % colors.length;
    nextColor = (nextColor + 1) % colors.length;
    return;
  }

  // Mouse interaction
  canvas.addEventListener('click', (event) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    let gridY = Math.floor(mouseY / vertSpacing);
    let gridX = Math.floor((mouseX - (gridY % 2) * (horizSpacing / 2)) / horizSpacing);

    if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
      // Apply a displacement pulse at the mouse location
      grid[gridX][gridY] = pulseMagnitude; // Adjust the magnitude of the pulse as needed
    }

    animate(0); // Start the animation loop
  });

</script>

<style>
  #background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    cursor: pointer;
  }
</style>